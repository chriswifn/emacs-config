#+title: Emacs configuration
#+author: Christian Hageloch
#+startup: overview

Currently tailored for GNU Emacs 28.2

Conventions of this configuration:
- Custom functions are prefixed by ~chris/~
- Custom variables are prefixed by ~chris-~

I try to fulfill these conventions but sometimes I forget about it.

* Early init file
:PROPERTIES:
:header-args: :tangle early-init.el
:END:

~straight.el~ is used as the package management system.
To revent ~package.el~ from loading packages the following piece of code is necessary prior to
loading the init file

#+begin_src emacs-lisp
;;; early-init.el --- Early Init File -*- lexical-binding: t; no-byte-compile: t -*-
(setq gc-cons-threshold (* 50 1000 1000))
(setq package-enable-at-startup nil)
#+end_src

Also disable some gui elements in the ~early-init.el~ file

#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)

(setq inhibit-splash-screen t
      use-file-dialog nil)
;;; early-init.el ends here
#+end_src


* Package management
:PROPERTIES:
:header-args: :tangle init.el
:END:

** ~init.el~ header

#+begin_src emacs-lisp
;;; init.el --- Personal configuration file -*- lexical-binding: t; no-byte-compile: t; -*-
#+end_src

** straight.el

[[https://github.com/raxod502/straight.el][GitHub - radian-software/straight.el]]

Some rules/conventions:

- When packages don't require installation, use ~:straight (:type built-in)~.
- Prefer multiple ~setq~ expressions to one.
- Prefer ~:init~ to ~:custom~.

** Boostrap ~straight.el~

#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package)
(straight-use-package 'org)
#+end_src


* Emacs
:PROPERTIES:
:header-args: :tangle init.el
:END:

Set some defaults for standard Emacs.
This includes:
- disable some gui features
- a function to reload the configuration file (~init.el~)
- setup up electric-pair-mode

** Defaults

Emacs has some weird choices enabled by default in the ui and setup.
Some of them are disabled in this configuration:
- No ~yes-or-no~ questions: instead use ~y-or-n~
- no backup files (managed by ~undo-tree~)
- no lockfiles (why would anyone want that?)
- no tabs
- enable ~hl-line-mode~ to see what line is currently active
- follow symlinks
- line-numbers in ~prog-mode~
- set all the encoding to ~utf-8~

#+begin_src emacs-lisp
(use-package emacs
  :straight (:type built-in)
  :config
  (setq user-full-name "Christian Hageloch")

  (defalias 'yes-or-no-p 'y-or-n-p) ;; life is too short

  (setq indent-tabs-mode nil) ;; no tabs

  (blink-cursor-mode -1) ;; no blinking

  (setq make-backup-files nil) ;; keep everything under vc 
  (setq auto-save-default nil)

  ;; keep backup and save files in a dedicated directory
  (setq backup-directory-alist
	`((".*" . ,(concat user-emacs-directory "backups")))
	auto-save-file-name-transforms
	`((".*" ,(concat user-emacs-directory "backups") t)))

  (setq create-lockfiles nil) ;; no need to create lockfiles

  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  (setq display-line-numbers-type 'relative)

  (column-number-mode)

  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  (global-hl-line-mode t)

  ;; Revert buffers when the underlying file has changed
  (global-auto-revert-mode 1)
  ;; Revert Dired and other buffers
  (setq global-auto-revert-non-file-buffers t)

  ;; follow symlinks
  (setq find-file-visit-truename t)

  (setq completion-cycle-threshold 3)
  (setq tab-always-indent 'complete)

  ;; encoding
  (set-charset-priority 'unicode) ;; utf8 in every nook and cranny
  (setq locale-coding-system 'utf-8
	coding-system-for-read 'utf-8
	coding-system-for-write 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix)))
#+end_src

** Reload the configuration file

Interactive function to load the ~init.el~ file.
In order to make changes take effect, this ~readme.org~ file has to be tangled (~C-c C-v C-t~)

#+begin_src emacs-lisp
(defun config-reload ()
  "Reload the configuration file"
  (interactive)
  (load-file (expand-file-name "~/.emacs.d/init.el")))
#+end_src

** Electric

Autocompletion of closing brackets and parenthesis.

#+begin_src emacs-lisp
(use-package electric
  :straight (:type built-in)
  :init
  (electric-pair-mode +1) ;; automatically insert closing parens 
  (setq electric-pair-preserve-balance nil)) ;; more annoying than useful
#+end_src


* Keybindings
:PROPERTIES:
:header-args: :tangle init.el
:END:

~Evil~ and ~General~ work quit well together.
~Hydra~ is useful for continuous keybindings.
~Whickkey~ is a package to display possible keybindings.

** General

[[https://github.com/noctuid/general.el][general.el]] provides a more convenient method for binding keys in emacs (for both evil and non-evil users).
Like =use-package=, which provides a convenient, unified interface for managing packages,
=general.el= is intended to provide a convenient, unified interface for key definitions.
While this package does implement some completely new functionality
(such as the ability to make vim-style keybindings under non-prefix keys with an optional timeout),
its primary purpose is to build on existing functionality to make key definition more clear and concise.
~general-define-key~ is user-extensible and supports defining multiple keys in multiple keymaps at once,
implicitly wrapping key strings with ~(kbd ...)~, using named prefix key sequences (like the leader key in vim),
and much more.

*** General setup

#+begin_src emacs-lisp
(use-package general
  :config
  ;; integrate general with evil
  (general-evil-setup)
  ;; set up 'SPC' as the global leader key
  (general-create-definer chris/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "M-SPC") ;; access leader in insert mode

  ;; set up ',' as the local leader key
  (general-create-definer chris/local-leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "," ;; set local leader
    :global-prefix "M-,") ;; access local leader in insert mode

  (general-define-key
   :states 'insert
   "C-g" 'evil-normal-state) ;; don't stretch for ESC

  ;; unbind some annoying default bindings
  (general-unbind
    "C-x C-r"	;; unbind find file read only
    "C-x C-z"	;; unbind suspend frame
    "C-x C-d"	;; unbind list directory
    "<mouse-2>") ;; pasting with mouse wheel click

  (chris/leader-keys
    "SPC" '(execute-extended-command :wk "execute command"))) ;; an alternative to 'M-x'
#+end_src

*** Keybindings for files

| Keybinding | Function            | Description                                              |
|------------+---------------------+----------------------------------------------------------|
| SPC f f    | find-file           | Find a file in current working directory                 |
| SPC f z    | affe-find           | Affe is a fuzzy finder (also works in current directory) |
| SPC f g    | affe-grep           | Affe but not with files and rather with grep             |
| SPC f r    | consult-recent-file | Find recently opened files using recentf                 |
| SPC f s    | save-buffer         | Save a file                                              |
| SPC f u    | sudo-edit-find-file | Open a file as sudo                                      |
| SPC f C    | copy-file           | Copy the current file                                    |
| SPC f D    | delete-file         | Delete the current file                                  |
| SPC f R    | rename-file         | Rename the current file                                  |
| SPC f S    | write-file          | Safe the current file as <name>                          |
| SPC f U    | sudo-edit           | Convert file write process to sudo                       |

#+begin_src emacs-lisp
(chris/leader-keys
  "f" '(:ignore t :wk "file")
  "ff" '(find-file :wk "find file")
  "fz" '(affe-find :wk "fuzzy finder")
  "fg" '(affe-grep :wk "fuzzy finder (grep)")
  "fr" '(consult-recent-file :wk "Recent files")
  "fs" '(save-buffer :wk "Save file")
  "fu" '(sudo-edit-find-file :wk "Sudo find file")
  "fC" '(copy-file :wk "Copy file")
  "fD" '(delete-file :wk "Delete file")
  "fR" '(rename-file :wk "Rename file")
  "fS" '(write-file :wk "Save file as...")
  "fU" '(sudo-edit :wk "Sudo edit file"))
#+end_src

*** Keybindings for buffers

| Keybinding | Function                     | Description                                                                     |
|------------+------------------------------+---------------------------------------------------------------------------------|
| SPC b i    | ibuffer                      | Open ibuffer                                                                    |
| SPC b b    | consult-buffer               | Pick buffer from a list of open buffers                                         |
| SPC b f    | chris/toggle-maximize-buffer | Toggle monocle mode for currently focused buffer                                |
| SPC b k    | kill-current-buffer          | Kill the current buffer                                                         |
| SPC b v    | chris/buffers-vc-root        | Pick buffer from a list of open buffers in current project directory            |
| SPC b m    | chris/buffers-major-mode     | Picks buffer from a list of open buffers with same major mode of current buffer |
| SPC b n    | next-buffer                  | Goto the next buffer                                                            |
| SPC b p    | previous-buffer              | Goto the previous buffer                                                        |
| SPC b B    | ibuffer-list-buffers         | Get a list of all open buffers                                                  |
| SPC b r    | revert-buffer                | Revert the buffer to the initial state                                          |
| SPC b s    | chris/simple-scratch-buffer  | Open a scratch buffer with same major mode as current buffer                    |
| SPC b K    | kill-buffer                  | Pick from a menu of buffers to kill                                             |

#+begin_src emacs-lisp
(chris/leader-keys
  "b" '(:ignore t :wk "buffer")
  "bi" '(ibuffer :wk "ibuffer")
  "bb" '(consult-buffer :wk "switch buffer")
  "bf" '(chris/toggle-maximize-buffer :wk "Toggle maximize buffer")
  "bc" '(clone-indirect-buffer-other-window :wk "Clone indirect buffer other window")
  "bk" '(kill-current-buffer :wk "Kill current buffer")
  "bv" '(chris/buffers-vc-root :wk "Buffers in project root") 
  "bm" '(chris/buffers-major-mode :wk "Buffers with same major mode")
  "bn" '(next-buffer :wk "Next buffer")
  "bp" '(previous-buffer :wk "Previous buffer")
  "bB" '(ibuffer-list-buffers :wk "Ibuffer list buffers")
  "br" '(revert-buffer :wk "Revert Buffer")
  "bs" '(chris/simple-scratch-buffer :wk "Revert Buffer")
  "bK" '(kill-buffer :wk "Kill buffer"))
#+end_src

*** Keybindings to toggle things

| Keybinding | Function                  | Description                         |
|------------+---------------------------+-------------------------------------|
| SPC t r    | config-reload             | Reload the configuration (~init.el~)  |
| SPC t l    | chris/toggle-line-numbers | Toggle visibility of line numbers   |
| SPC t m    | chris/hide-mode-line-mode | Hide visibility of the modeline     |
| SPC t t    | modus-themes-toggle       | Toggle between the two modus-themes |

#+begin_src emacs-lisp
(chris/leader-keys
  "t"  '(:ignore t :wk "toggle")
  "tr" '(config-reload :wk "config")
  "tl" '(chris/toggle-line-numbers :wk "linenumbers")
  "tm" '(chris/hide-mode-line-mode :wk "linenumbers")
  "ts" '(chris/tab-status-line :wk "tab-bar-line")
  "tt" '(modus-themes-toggle :wk "theme"))
#+end_src

*** Keybindings to open programs within emacs

| Keybinding | Function                | Description                                  |
|------------+-------------------------+----------------------------------------------|
| SPC o t    | vterm                   | Open a vterm buffer                          |
| SPC o e    | eshell                  | Open an eshell buffer                        |
| SPC o s    | fontaine-set-preset     | Choose a fontaine preset                     |
| SPC o w    | woman                   | Pick from a list of manpages and display it  |
| SPC o f    | chris/olivetti-mode     | Open custom olivetti for better focus        |
| SPC o u    | undo-tree-visualize     | Open undo-tree                               |
| SPC o l    | org-toggle-link-display | Display org-mode links (don't truncate them) |
| SPC o c    | org-capture             | Open org-capture for "note-taking"           |
| SPC o a    | org-agenda              | Open org-agenda for "taks-scheduling"        |
| SPC o o    | occur "^*+"             | Get an outline (headings) of org-mode files  |

#+begin_src emacs-lisp
(chris/leader-keys
  "o" '(:ignore t :wk "open")
  "ot" '(vterm :wk "vterm")
  "oe" '(eshell :wk "eshell")
  "op" '(list-processes :wk "get a list of processes")
  "os" '(fontaine-set-preset :wk "fontaine")
  "ow" '(woman :wk "woman")
  "of" '(chris/olivetti-mode :wk "olivetti")
  "ou" '(undo-tree-visualize :wk "undo-tree")
  "ol" '(org-toggle-link-display :wk "Display org links")
  "oc" '(org-capture :wk "org campture")
  "oa" '(org-agenda :wk "org campture")
  "oo" '(occur "^*+" :wk "org sidebar"))
#+end_src

*** Keybindings for code

| Keybinding | Function                        | Description                                    |
|------------+---------------------------------+------------------------------------------------|
| SPC c c    | compile                         | Compile function                               |
| SPC c d    | flymake-show-buffer-diagnostics | Show errors in lsp-buffer (eglot in this case) |
| SPC c m    | open-matlab-shell               | Open matlab shell in matlab buffer             |

#+begin_src emacs-lisp
(chris/leader-keys
"c" '(:ignore t :wk "code")
"cc" '(compile :wk "Compile")
"cd" '(flymake-show-buffer-diagnostics :wk "show lsp diagnostics")
"cm" '(open-matlab-shell :wk "Open Matlab shell"))
#+end_src

** Hydra

Once you summon the [[https://github.com/abo-abo/hydra][hydra]] through the prefixed binding (the body + any one head),
all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head, arrives.
Note that Hercules, besides vanquishing the Hydra, will still serve his original purpose, calling his proper command.
This makes the Hydra very seamless, it's like a minor mode that disables itself auto-magically.

#+begin_src emacs-lisp
(use-package hydra
  :defer t
  :config
  ;; scale text
  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

  ;; split size
  (defhydra hydra-split-size (:timeout 4)
    "increase/decrease split size"
    ("h" shrink-window-horizontally)
    ("j" enlarge-window)
    ("k" shrink-window)
    ("l" enlarge-window-horizontally)
    ("n" balance-windows)
    ("f" nil "finished" :exit t))

  ;; bluetooth
  (defhydra hydra-bluetooth (:timeout 4)
    "connect/disconnect from bluetooth"
    ("c" (start-process-shell-command "bluetoothctl" nil "bluetoothctl -- connect E8:EE:CC:00:AD:24"))
    ("d" (start-process-shell-command "bleutoothctl" nil "bluetoothctl -- disconnect"))
    ("f" nil "finished" :exit t))
  :general
  (chris/leader-keys
    "h" '(:ignore t :wk "hydra")
    "hf" '(hydra-text-scale/body :wk "scale text")
    "hs" '(hydra-split-size/body :wk "split size")
    "hb" '(hydra-bluetooth/body :wk "bluetooth")))
#+end_src

** Evil

[[https://github.com/emacs-evil/evil][Evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on EmacsWiki.

*** General evil setup

#+begin_src emacs-lisp
(use-package evil
  :general
  (chris/leader-keys
    "w" '(:keymap evil-window-map :wk "window")) ;; window bindings
  :init
  (setq evil-search-module 'isearch)

  (setq evil-want-C-u-scroll t) ;; allow scroll up with 'C-u'
  (setq evil-want-C-d-scroll t) ;; allow scroll down with 'C-d'

  (setq evil-want-integration t) ;; necessary for evil collection
  (setq evil-want-keybinding nil)

  (setq evil-split-window-below t)
  (setq evil-vsplit-window-right t)

  ;; cursors
  (setq evil-normal-state-cursor 'box)
  (setq evil-insert-state-cursor 'box)
  (setq evil-visual-state-cursor 'box)
  (setq evil-motion-state-cursor 'box)
  (setq evil-replace-state-cursor 'box)
  (setq evil-operator-state-cursor 'box)

  (setq evil-want-C-i-jump nil) ;; hopefully this will fix weird tab behaviour

  (setq evil-undo-system 'undo-tree) ;; undo via 'u', and redo the undone change via 'C-r'; only available in emacs 28+.
  :config
  (evil-mode t) ;; globally enable evil mode
  ;; set the initial state for some kinds of buffers.
  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal)
  ;; buffers in which I want to immediately start typing should be in 'insert' state by default.
  (evil-set-initial-state 'eshell-mode 'insert)
  (evil-set-initial-state 'magit-diff-mode 'insert))
#+end_src

*** Undo-tree

Emacs has a powerful undo system ([[https://elpa.gnu.org/packages/undo-tree.html][undo-tree]]). Unlike the standard undo/redo system in
most software, it allows you to recover *any* past state of a buffer
(whereas the standard undo/redo system can lose past states as soon as you
redo). However, this power comes at a price: many people find Emacs' undo
system confusing and difficult to use, spawning a number of packages that
replace it with the less powerful but more intuitive undo/redo system.

#+begin_src emacs-lisp
(use-package undo-tree
  :after evil
  :config
  (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
  :init
  (global-undo-tree-mode))
#+end_src

*** Evil collection

This is a collection of Evil bindings for the parts of Emacs that Evil does not cover properly by default, such as help-mode, M-x calendar, Eshell and more.
[[https://github.com/emacs-evil/evil-collection][evil-collection]]

#+begin_src emacs-lisp
(use-package evil-collection ;; evilifies a bunch of things
  :after evil
  :init
  (setq evil-collection-outline-bind-tab-p t) ;; '<TAB>' cycles visibility in 'outline-minor-mode'
  ;; If I want to incrementally enable evil-collection mode-by-mode, I can do something like the following:
  ;; (setq evil-collection-mode-list nil) ;; I don't like surprises
  ;; (add-to-list 'evil-collection-mode-list 'magit) ;; evilify magit
  ;; (add-to-list 'evil-collection-mode-list '(pdf pdf-view)) ;; evilify pdf-view
  :config
  (evil-collection-init))
#+end_src

*** Evil org

[[https://github.com/Somelauw/evil-org-mode][evil-org-mode]] is used to supplemental evil-mode key-bindings to Emacs org-mode.

#+begin_src emacs-lisp
(use-package evil-org
  :after org
  :hook (org-mode . (lambda () evil-org-mode))
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+end_src

*** Evil commentary

[[https://github.com/linktohack/evil-commentary][evil-commentary]] is an Emacs package for evil-mode that intends to make it easy to comment out (lines of) code:

- ~gcc~ comments out a line (takes a count)
-  ~gc~ comments out the target of a motion, e.g. gcap to comment out a paragraph (normal state) and gc to comment out the selection (visual state).


#+begin_src emacs-lisp
(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode)) ;; globally enable evil-commentary
#+end_src

*** Change C-d and C-u behavior

When jumping with ~C-d~ and ~C-u~ the current jump-line should be centered imo.

#+begin_src emacs-lisp
(defun scroll-down-and-center ()
  (interactive)
  (evil-scroll-down 0)
  (evil-scroll-line-to-center (line-number-at-pos)))

(define-key evil-motion-state-map "\C-d" 'scroll-down-and-center)

(defun scroll-up-and-center ()
  (interactive)
  (evil-scroll-up 0)
  (evil-scroll-line-to-center (line-number-at-pos)))

(define-key evil-motion-state-map "\C-u" 'scroll-up-and-center)
#+end_src

** Whichkey

[[https://github.com/justbur/emacs-which-key][which-key]] a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.
For example, after enabling the minor mode if you enter C-x and wait for the default of 1 second the minibuffer will expand with all
of the available key bindings that follow C-x (or as many as space allows given your settings).
This includes prefixes like C-x 8 which are shown in a different face.
Screenshots of what the popup will look like are included below. which-key started as a rewrite of guide-key-mode,
but the feature sets have diverged to a certain extent.

#+begin_src emacs-lisp
(use-package which-key
  :after evil
  :init (which-key-mode)
  :config
  (which-key-setup-minibuffer))
#+end_src


* Org mode
:PROPERTIES:
:header-args: :tangle init.el
:END:
 
[[https://orgmode.org/][Org]] is a highly flexible structured plain text file format, composed of a few simple, yet versatile,
structures — constructed to be both simple enough for the novice and powerful enough for the expert. 

** General org-mode configuration

Some basic settings for org-mode.
To easily insert blocks press ~C-c C-,~.

#+begin_src emacs-lisp
(use-package org
  :config
  (setq org-ellipsis " ")
  (setq orc-src-fontify-natively t)
  (setq src-tab-acts-natively t)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-block-delimiter-line t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (setq org-hide-emphasis-markers t)
  (setq org-src-preserve-indentation 1)
  (setq org-edit-src-content-indentation 0)

  ;; configure babel languages
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (shell . t)))

    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))

    (push '("conf-unix" . conf-unix) org-src-lang-modes))

  (setq org-directory "~/org")
  (setq org-default-notes-file (concat org-directory "/notes.org")))

(use-package org-download
  :config
  (setq org-download-screenshot-method "maim -s %s"))
#+end_src

** org-agenda

Organize your life with org-agenda.

#+begin_src emacs-lisp
(setq org-agenda-files '("~/org/Agenda.org"))
(setq org-agenda-start-with-log-mode t)
(setq org-log-done 'time)
(setq org-log-into-drawer t)
(setq org-log-done 'time)
#+end_src

** org-roam

[[https://github.com/org-roam/org-roam][Org-roam]] is a plain-text knowledge management system. It brings some of Roam's more powerful features into the Org-mode ecosystem.

Org-roam borrows principles from the Zettelkasten method, providing a solution for non-hierarchical note-taking.
It should also work as a plug-and-play solution for anyone already using Org-mode for their personal wiki.

#+begin_src emacs-lisp
(use-package org-roam
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/orgroam")
  (org-roam-compeltion-everywhere t)
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert))
  :general
  (chris/leader-keys
    "r" '(:ignore t :wk "org-roam")
    "rt" '(org-roam-buffer-toggle :wk "toggle org-roam buffer")
    "rf" '(org-roam-node-find :wk "find node")
    "ri" '(org-roam-node-insert :wk "insert node"))
  (chris/leader-keys "rd" '(:keymap org-roam-dailies-map :wk "dailies"))
  :config
  (require 'org-roam-dailies)
  (org-roam-db-autosync-mode)
  (org-roam-setup))
#+end_src


* Appearance
:PROPERTIES:
:header-args: :tangle init.el
:END:

This section is dedicated to setting appearance related settings.

** Fonts

[[https://github.com/protesilaos/fontaine][fontaine]] lets the user specify presets of font configurations and set them on demand on graphical Emacs frames. The user option fontaine-presets holds all such presets.

Presets consist of a list of properties that govern the family, weight, and height of the faces default, fixed-pitch,
fixed-pitch-serif, variable-pitch, bold, and italic.
Each preset is identified by a user-defined symbol as the car of a property list.
It looks like this (check the default value of fontaine-presets for how everything is pieced together):

The font is Protesilaos Stavrou's patched [[https://gitlab.com/protesilaos/iosevka-comfy][Iosevka Comfy]] Font.

#+begin_src emacs-lisp  
(use-package fontaine
  :config
  (setq x-underline-at-descent-line t)
  (setq-default text-scale-remap-header-line t)
  (fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular))
  :init
  (setq fontaine-presets
	'((tiny
	   :default-family "Iosevka Comfy Wide Fixed"
	   :default-height 70)
	  (small
	   :default-family "Iosevka Comfy Fixed"
	   :default-height 90)
	  (regular
	   :default-height 110)
	  (medium
	   :default-height 120)
	  (large
	   :default-weight semilight
	   :default-height 140
	   :bold-weight extrabold)
	  (code
	   :default-weight semilight
	   :default-height 160
	   :bold-weight extrabold)
	  (presentation
	   :default-weight semilight
	   :default-height 170
	   :bold-weight extrabold)
	  (t
	   ;; I keep all properties for didactic purposes, but most can be
	   ;; omitted.  See the fontaine manual for the technicalities:
	   ;; <https://protesilaos.com/emacs/fontaine>.
	   :default-family "Iosevka Comfy Wide"
	   :default-weight regular
	   :default-height 110 
	   :fixed-pitch-family nil ; falls back to :default-family
	   :fixed-pitch-weight nil ; falls back to :default-weight
	   :fixed-pitch-height 1.0
	   :variable-pitch-family "Iosevka Comfy Duo"
	   :variable-pitch-weight nil
	   :variable-pitch-height 1.0
	   :bold-family nil ; use whatever the underlying face has
	   :bold-weight bold
	   :italic-family nil
	   :italic-slant italic
	   :line-spacing nil))))
#+end_src

** Useful output

Some scripts that ouput standard out to minibuffer.

#+begin_src emacs-lisp
;; some useful output to display in the modeline
(display-battery-mode 1)
(column-number-mode 1)

;; display the current time and date in the minibuffer
(defun display-current-time ()
  (interactive)
  (message (format-time-string "%Y-%m-%d %H:%M:%S")))
(define-key global-map (kbd "<f1>") #'display-current-time)

;; display wifi/eth/vpn status in the minibuffer
(defun display-wifi-status ()
  (interactive)
  (message (shell-command-to-string "sb-internet-emacs")))
(define-key global-map (kbd "<f2>") #'display-wifi-status)
#+end_src

** Theme

The [[https://protesilaos.com/emacs/modus-themes#h:f0f3dbcb-602d-40cf-b918-8f929c441baf][Modus]] themes are designed for accessible readability.
They conform with the highest standard for color contrast between any given combination of background and foreground values.
This corresponds to the WCAG AAA standard, which specifies a minimum rate of distance in relative luminance of 7:1.

Modus Operandi (~modus-operandi~) is a light theme, while Modus Vivendi (~modus-vivendi~) is dark.
Each theme’s color palette is designed to meet the needs of the numerous interfaces that are possible in the Emacs computing environment. 

#+begin_src emacs-lisp
(use-package modus-themes
  :config
  (setq modus-themes-bold-constructs t
        modus-themes-italic-construct nil
        modus-themes-subtle-line-numbers nil
        modus-themes-fringes '(subtle)
        modus-themes-hl-line '(intense)
        modus-themes-mode-line '(borderless (padding . 4))
        modus-themes-syntax '(faint green-strings alt-syntax)
        modus-themes-headings
        '((1 . (1.3))
          (2 . (1.2))
          (3 . (1.1))
          (t . (1.0)))
        modus-themes-org-blocks 'gray-background))
(define-key global-map (kbd "C-c t") #'modus-themes-toggle)
(modus-themes-load-vivendi)
#+end_src

** Modeline

The [[https://github.com/emacsmirror/diminish][diminish]] implements hiding or abbreviation of the mode line displays (lighters) of minor-modes.
#+begin_src emacs-lisp
(use-package diminish)
(diminish 'auto-revert-mode)
(diminish 'evil-collection-unimpaired-mode)
(diminish 'which-key-mode)
(diminish 'evil-commentary-mode)
(diminish 'undo-tree-mode)
(diminish 'eldoc-mode)
#+end_src


* Bottom menu
:PROPERTIES:
:header-args: :tangle init.el
:END:

** Vertico and orderless

[[https://github.com/minad/vertico][vertico]] provides a performant and minimalistic vertical completion UI based on the default completion system.
The focus of Vertico is to provide a UI which behaves correctly under all circumstances.
By reusing the built-in facilities system, Vertico achieves full compatibility with built-in Emacs completion commands and completion tables.
Vertico only provides the completion UI but aims to be highly flexible, extendable and modular.
Additional enhancements are available as extensions or complementary packages.
The code base is small and maintainable.
The main vertico.el package is only about 600 lines of code without white space and comments.

The [[https://github.com/oantolin/orderless][orderless]] package provides an orderless completion style that divides the pattern into space-separated components,
and matches candidates that match all of the components in any order.
Each component can match in any one of several ways: literally, as a regexp, as an initialism,
in the flex style, or as multiple word prefixes. By default, regexp and literal matches are enabled.


#+begin_src emacs-lisp
(use-package vertico
  :init
  (vertico-mode +1))

(use-package orderless
  :init
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((fie (styles partial-completion)))))
#+end_src

** Consult

[[https://github.com/minad/consult][consult]] provides practical commands based on the Emacs completion function completing-read.
Completion allows you to quickly select an item from a list of candidates.
Consult offers in particular an advanced buffer switching command consult-buffer to switch between buffers and recently opened files.
Furthermore Consult provides multiple search commands, an asynchronous consult-grep and consult-ripgrep,
and the line-based search command consult-line. Some of the Consult commands are enhanced versions of built-in Emacs commands.

#+begin_src emacs-lisp
(use-package consult
  :init
  (setq consult-preview-key "$")
  :bind ("C-s" . 'consult-line))

(recentf-mode +1)
#+end_src

** Affe

The [[https://github.com/minad/affe][affe]] package provides an asynchronous fuzzy finder similar to the fzf command-line fuzzy finder, written in pure Elisp.
A producer process is started in the background, e.g., find or grep.
The output produced by this process is filtered by an external asynchronous Emacs process.
The Emacs UI always stays responsive since the work is off-loaded to other processes.
The results are presented in the minibuffer using Consult, which allows to quickly select from the available items.

#+begin_src emacs-lisp
(use-package affe
  :after orderless
  :init
  (setq affe-regexp-function #'orderless-pattern-compiler
        affe-highlight-function #'orderless-highlight-matches)
  (consult-customize affe-grep :preview-key (kbd "M-.")))
#+end_src

** Savehist

A very simple alternative to more involved SessionManagement solutions.
[[https://www.emacswiki.org/emacs/SaveHist][savehist]]

#+begin_src emacs-lisp
(use-package savehist
  :straight (:type built-in)
  :config
  (setq history-length 25)
  :init
  (savehist-mode))
#+end_src

** Marginalia

The [[https://github.com/minad/marginalia][marginalia]] package provides marginalia-mode which adds marginalia to the minibuffer completions.
Marginalia are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations
placed at the margin of the minibuffer for your completion candidates.
Marginalia can only add annotations to the completion candidates.
It cannot modify the appearance of the candidates themselves, which are shown unaltered as supplied by the original command.

#+begin_src emacs-lisp
(use-package marginalia
  :after vertico
  :ensure t
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :init
  (marginalia-mode))
#+end_src


* File management
:PROPERTIES:
:header-args: :tangle init.el
:END:

This section provides some useful file-management tools.

** Dired

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][Dired]] makes an Emacs buffer containing a listing of a directory, and optionally some of its subdirectories as well.
You can use the normal Emacs commands to move around in this buffer,
and special Dired commands to operate on the listed files. Dired works with both local and remote directories. 

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :general
  (chris/leader-keys
    "d" '(:ignore t :wk "dired")
    "dd" '(dired :wk "Open Dired")
    "dj" '(dired-jump :wk "Jump to current directory in dired"))
  :config
  (put 'dired-find-alternate-file 'disabled nil))
#+end_src

** Sudo Edit

Open files with elevated priviliges.

#+begin_src emacs-lisp
(use-package sudo-edit)
#+end_src

** 0x0

Integration with 0x0.st services from emacs. Intended for use in ERC to share images, files, and blocks of code.
[[https://github.com/emacsmirror/0x0][0x0]]

#+begin_src emacs-lisp
(use-package 0x0
  :general
  (chris/leader-keys
    "x" '(:ignore t :wk "web")
    "x;" '(0x0-dwim t :wk "0x0 dwim")
    "xt" '(0x0-upload-text :wk "0x0 upload text")
    "xf" '(0x0-upload-file :wk "0x0 upload file")
    "xk" '(0x0-upload-kill-ring :wk "0x0 upload kill ring")
    "xp" '(0x0-popup :wk "0x0 popup")
    "xs" '(0x0-shorten-uri :wk "0x0 shorten url")))
#+end_src

** Openwith

[[https://github.com/thisirs/openwith][openwith]] is a simple but very useful package to make Emacs associate various file types with external applications.
For example, Emacs can open PDFs, but you may want to open them with a dedicated PDF viewer instead.
With openwith, you can do this seamlessly when you use C-x C-f.  It also works with recentf and ido.

#+begin_src emacs-lisp
(use-package openwith
  :config
  (setq openwith-associations
        (list
         (list (openwith-make-extension-regexp
                '("doc" "xls" "xlsx" "ppt" "odt" "ods" "odg" "odp"))
               "$HOME/.local/share/applications/LibreOffice-still.basic-x86_64.AppImage"
               '(file))
         ))
  (openwith-mode 1))
#+end_src

** Calendar

German holidays for Calendar.

#+begin_src emacs-lisp
(setq calendar-week-start-day 1
      calendar-day-name-array ["Sonntag" "Montag" "Dienstag" "Mittwoch"
			       "Donnerstag" "Freitag" "Samstag"]
      calendar-month-name-array ["Januar" "Februar" "März" "April" "Mai"
				 "Juni" "Juli" "August" "September"
				 "Oktober" "November" "Dezember"])
(setq solar-n-hemi-seasons
      '("Frühlingsanfang" "Sommeranfang" "Herbstanfang" "Winteranfang"))

(setq holiday-general-holidays
      '((holiday-fixed 1 1 "Neujahr")
        (holiday-fixed 5 1 "1. Mai")
        (holiday-fixed 10 3 "Tag der Deutschen Einheit")))

;; Feiertage für Bayern, weitere auskommentiert
(setq holiday-christian-holidays
      '((holiday-float 12 0 -4 "1. Advent" 24)
        (holiday-float 12 0 -3 "2. Advent" 24)
        (holiday-float 12 0 -2 "3. Advent" 24)
        (holiday-float 12 0 -1 "4. Advent" 24)
        (holiday-fixed 12 25 "1. Weihnachtstag")
        (holiday-fixed 12 26 "2. Weihnachtstag")
        (holiday-fixed 1 6 "Heilige Drei Könige")
        (holiday-easter-etc -48 "Rosenmontag")
        ;; (holiday-easter-etc -3 "Gründonnerstag")
        (holiday-easter-etc  -2 "Karfreitag")
        (holiday-easter-etc   0 "Ostersonntag")
        (holiday-easter-etc  +1 "Ostermontag")
        (holiday-easter-etc +39 "Christi Himmelfahrt")
        (holiday-easter-etc +49 "Pfingstsonntag")
        (holiday-easter-etc +50 "Pfingstmontag")
        (holiday-easter-etc +60 "Fronleichnam")
        (holiday-fixed 8 15 "Mariae Himmelfahrt")
        (holiday-fixed 11 1 "Allerheiligen")
        ;; (holiday-float 11 3 1 "Buss- und Bettag" 16)
        (holiday-float 11 0 1 "Totensonntag" 20)))

(setq calendar-holidays holiday-christian-holidays)
#+end_src

** Olivetti

[[https://github.com/rnkn/olivetti][olivetti]] is a simple Emacs minor mode for a nice writing environment.

The minor mode =chris/olivetti-mode= automatically toggles the visibility
of the mode-line and sets the width of the display to 120 characters.

#+begin_src emacs-lisp
(use-package olivetti
  :config
  (setq olivetti-body-width 0.65)
  (setq olivetti-minimum-body-width 72)
  (setq olivetti-recall-visual-line-mode-entry-state t)

  (define-minor-mode chris/olivetti-mode
    "Toggle buffer-local `olivetti-mode' with additional parameters.
Fringes are disabled.  The modeline is hidden, except for
`prog-mode' buffers (see `chris/hidden-mode-line-mode')."
    :init-value nil
    :global nil
    (if chris/olivetti-mode
        (progn
          (olivetti-mode 1)
	  (olivetti-set-width 120)
          (set-window-fringes (selected-window) 0 0)
          (unless (derived-mode-p 'prog-mode)
            (chris/turn-on-hide-mode-line-mode))
          (window-divider-mode 1))
      (olivetti-mode -1)
      (set-window-fringes (selected-window) nil) ; Use default width
      (unless (derived-mode-p 'prog-mode)
        (chris/turn-off-hide-mode-line-mode))
      (window-divider-mode -1)
      )))

;; this piece of code is directly copied from Hlissner
;; I attach a prefix to dinstinguish custom functions
(defvar chris/hide-mode-line-format nil
  "The modeline format to use when `chris/hide-mode-line-mode' is active.")

(defvar chris/hide-mode-line-excluded-modes '(fundamental-mode)
  "List of major modes where `chris/global-hide-mode-line-mode' won't affect.")

(defvar-local chris/hide-mode-line--old-format nil
  "Storage for the old `mode-line-format', so it can be restored when
`chris/hide-mode-line-mode' is disabled.")

(define-minor-mode chris/hide-mode-line-mode
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :global nil
  (if chris/hide-mode-line-mode
      (progn
	(add-hook 'after-change-major-mode-hook #'chris/hide-mode-line-mode nil t)
	(unless chris/hide-mode-line--old-format
	  (setq chris/hide-mode-line--old-format mode-line-format))
	(setq mode-line-format chris/hide-mode-line-format))
    (remove-hook 'after-change-major-mode-hook #'chris/hide-mode-line-mode t)
    (setq mode-line-format chris/hide-mode-line--old-format
	  chris/hide-mode-line--old-format nil))
  (when (called-interactively-p 'any)
    (redraw-display)))

;; Ensure major-mode or theme changes don't overwrite these variables
(put 'chris/hide-mode-line--old-format 'permanent-local t)
(put 'chris/hide-mode-line-mode 'permanent-local-hook t)

(define-globalized-minor-mode chris/global-hide-mode-line-mode
  chris/hide-mode-line-mode chris/turn-on-hide-mode-line-mode
  (redraw-display))

(defun chris/turn-on-hide-mode-line-mode ()
  "Turn on `chris/hide-mode-line-mode'.
Unless in `fundamental-mode' or `chris/hide-mode-line-excluded-modes'."
  (unless (memq major-mode chris/hide-mode-line-excluded-modes)
    (chris/hide-mode-line-mode +1)))

(defun chris/turn-off-hide-mode-line-mode ()
  "Turn off `chris/hide-mode-line-mode'."
  (chris/hide-mode-line-mode -1))
#+end_src


* Buffer management
:PROPERTIES:
:header-args: :tangle init.el
:END:

This section is dedicated to provide some useful features in managing buffers.

** Get all buffers with same major mode as current file

=chris/buffers-major-mode= provides a list of all open buffers that share the same
major mode as the current buffer.

#+begin_src emacs-lisp
(defun chris/buffers-major-mode (&optional arg)
  "Select buffers that match the current buffer's major mode.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly.  Else use standard completion."
  (interactive "P")
  (let* ((major major-mode)
	 (prompt "Buffers for ")
	 (mode-string (format "%s" major))
	 (mode-string-pretty (propertize mode-string 'face 'success)))
    (if arg
	(ibuffer t (concat "*" prompt mode-string "*")
		 (list (cons 'used-mode major)))
      (switch-to-buffer
       (read-buffer
	(concat prompt mode-string-pretty ": ") nil t
	(lambda (pair) ; pair is (name-string . buffer-object)
	  (with-current-buffer (cdr pair) (derived-mode-p major))))))))
#+end_src

** Get all buffers in current project (vc-root)

=chris/buffers-vc-root= provides a list of all open buffers that share the same
project-root (~vc-root~) as the current buffer.

#+begin_src emacs-lisp
(defun chris/buffers-vc-root (&optional arg)
  "Select buffers that match the present `vc-root-dir'.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly.  Else use standard completion.

When no VC root is available, use standard `switch-to-buffer'."
  (interactive "P")
  (let* ((root (vc-root-dir))
         (prompt "Buffers for VC ")
         (vc-string (format "%s" root))
         (vc-string-pretty (propertize vc-string 'face 'success)))
    (if root
        (if arg
            (ibuffer t (concat "*" prompt vc-string "*")
                     (list (cons 'filename (expand-file-name root))))
          (switch-to-buffer
           (read-buffer
            (concat prompt vc-string-pretty ": ") nil t
            (lambda (pair) ; pair is (name-string . buffer-object)
              (with-current-buffer (cdr pair) (string= (vc-root-dir) root))))))
      (call-interactively 'switch-to-buffer))))
#+end_src

** Maximize a buffer

=chris/toggle-maximize-buffer= is a function to toggle the maximized display of
the currently focused buffer.

#+begin_src emacs-lisp
(defun chris/toggle-maximize-buffer ()
  "Maximize buffer"
  (interactive)
  (if (= 1 (length (window-list)))
      (jump-to-register '_) 
    (progn
      (window-configuration-to-register '_)
      (delete-other-windows))))
#+end_src

** dired buffer

Conveniently configure dired and a function to kill all open dired buffers.

#+begin_src emacs-lisp
(defun chris/kill-dired-buffers ()
  "Kill all open dired buffers."
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))
#+end_src

** Create custom scratch buffers

=chris/simple-scratch-buffer= is a function to dynamically create scratch buffers based on
currently active buffer.

Expected behavior:

- If the current major mode is derived from ~prog-mode~, it opens a scratch buffer with the
  current major mode
- If the current major mode is not derived from ~prog-mode~, it promps for a selection of
  all possible ~prog-mode~ derivatives =AND= ~org-mode~ as an additional selection item

#+begin_src emacs-lisp
;;; Generic setup
(defun chris/simple--scratch-list-modes ()
  "List known major modes."
  (cl-loop for sym the symbols of obarray
	   when (and (functionp sym)
		     (and (provided-mode-derived-p sym 'prog-mode 'org-mode)))
	   collect sym))

(defun chris/simple--scratch-buffer-setup (region &optional mode)
  "Add contents to `scratch' buffer and name it accordingly.

REGION is added to the contents to the new buffer.

Use the current buffer's major mode by default.  With optional
MODE use that major mode instead."
  (let* ((major (or mode major-mode))
         (string (format "Scratch buffer for: %s\n\n" major))
         (text (concat string region))
         (buf (format "*Scratch for %s*" major)))
    (with-current-buffer (get-buffer-create buf)
      (funcall major)
      (save-excursion
        (insert text)
        (goto-char (point-min))
        (comment-region (point-at-bol) (point-at-eol)))
      (vertical-motion 2))
    (pop-to-buffer buf)))

(defun chris/simple-scratch-buffer (&optional arg)
  "Produce a bespoke scratch buffer matching current major mode.

If the major-mode is not derived from 'prog-mode, it prompts for
a list of all derived prog-modes AND org-mode

If region is active, copy its contents to the new scratch
buffer."
  (interactive "P")
  (let* ((modes (chris/simple--scratch-list-modes))
         (region (with-current-buffer (current-buffer)
                   (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning)
                        (region-end))
                     "")))
         (m))
    (if (derived-mode-p 'prog-mode)
        (chris/simple--scratch-buffer-setup region)
      (progn
	(setq m (intern (completing-read "Select major mode: " modes nil t)))
	(chris/simple--scratch-buffer-setup region m)))))
#+end_src

** Toggle line numbers

=chris/toggle-line-numbers= is a function that toggles the display of line-numbers.

#+begin_src emacs-lisp
(defun chris/toggle-line-numbers ()
  "Toggles the display of line numbers. Applies locally to the current buffer"
  (interactive)
  (if (bound-and-true-p display-line-numbers-mode)
      (display-line-numbers-mode -1)
    (display-line-numbers-mode)))
#+end_src


* Projectile
:PROPERTIES:
:header-args: :tangle init.el
:END:

[[https://github.com/bbatsov/projectile][projectile]] is a project interaction library for Emacs.
Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible).
For instance - finding project files has a portable implementation written in pure Emacs Lisp without the use of GNU find
(but for performance sake an indexing mechanism backed by external commands exists as well).

#+begin_src emacs-lisp
(use-package projectile
  :general
  (chris/leader-keys "p" '(:keymap projectile-command-map :wk "projectile"))
  :init
  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (add-to-list 'projectile-globally-ignored-modes "org-mode"))
(setq projectile-indexing-method 'hybrid)

(use-package ibuffer-projectile
  :config 
  (add-hook 'ibuffer-hook
            (lambda ()
              (ibuffer-projectile-set-filter-groups)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic)))))
#+end_src


* Workspaces
:PROPERTIES:
:header-args: :tangle init.el
:END:

~tab-bar.el~ kind of emulates workspaces in a way if configured properly.
By default in this configuration the actual tab-bar at the top of the screen
is disabled.

#+begin_src emacs-lisp
(use-package tab-bar
  :straight (:type built-in)
  :general
  (chris/leader-keys
    "i" '(:keymap tab-prefix-map :wk "tab")
    "is" '(chris/tab-bar-select-tab-dwim :wk "tab-select"))
  :config
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice nil)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-current)
  (tab-bar-mode -1)
  (tab-bar-history-mode 1))
#+end_src

** Manage tabs

=chris/tab-bar-select-tab-dwim= manages tabs in the following way:
- if there is only one tab, the function will create a second one
- if there are exactly two tabs, it will toggle between them
- if there are more than two tabs, it will open a menu of the active tabs to choose from

#+begin_src emacs-lisp
(defun chris/tab-bar-select-tab-dwim ()
  "Do-What-I-Mean function for getting to a `tab-bar-mode' tab.
If no other tab exists, create one and switch to it.  If there is
one other tab (so two in total) switch to it without further
questions.  Else use completion to select the tab to switch to."
  (interactive)
  (let ((tabs (mapcar (lambda (tab)
                        (alist-get 'name tab))
                      (tab-bar--tabs-recent))))
    (cond ((eq tabs nil)
           (tab-new))
          ((eq (length tabs) 1)
           (tab-next))
          (t
           (consult-imenu ()
                          (tab-bar-switch-to-tab
                           (completing-read "Select tab: " tabs nil t)))))))
#+end_src

#+begin_src emacs-lisp
(define-minor-mode chris/tab-status-line
  "Make Tab bar a status line and configure the extras.
Hide the mode lines and change their colors."
  :global t
  (if chris/tab-status-line
      (progn
        (setq tab-bar-show t)
        (tab-bar-mode 1))
    (setq tab-bar-show nil)
    (tab-bar-mode -1)))
#+end_src


* IDE Features
:PROPERTIES:
:header-args: :tangle init.el
:END:

This section provides some useful IDE-"like" features.

** Completion

[[http://company-mode.github.io/][company]] is a text completion framework for Emacs. The name stands for "complete anything".
It uses pluggable back-ends and front-ends to retrieve and display completion candidates.

#+begin_src emacs-lisp
(use-package company
  :config
  (setq company-idle-delay 0)
  (setq company-minium-prefix-length 3))
#+end_src

** Indentation

electric-indent-mode is enough to keep your code nicely aligned when all you do is type.
However, once you start shifting blocks around, transposing lines, or slurping and barfing sexps, indentation is bound to go wrong.

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent-mode]] is a minor mode that keeps your code always indented. It reindents after every change, making it more reliable than electric-indent-mode.

#+begin_src emacs-lisp
(use-package aggressive-indent
  :diminish
  :init
  (global-aggressive-indent-mode 1))
(add-to-list 'aggressive-indent-excluded-modes 'python-mode)

(use-package highlight-indent-guides
  :diminish
  :config
  (setq highlight-indent-guides-auto-odd-face-perc 30)
  (setq highlight-indent-guides-auto-even-face-perc 35)
  (setq highlight-indent-guides-auto-character-face-perc 40)
  (setq highlight-indent-guides-method 'character)
  :hook
  (prog-mode . highlight-indent-guides-mode))
#+end_src

** LSP

[[https://github.com/joaotavora/eglot][eglot]] is a client for Language Server Protocol servers 

#+begin_src emacs-lisp
(use-package eglot
  :commands
  eglot)
#+end_src

** Treesitter

[[https://emacs-tree-sitter.github.io/][tree-sitter]] is an Emacs binding for Tree-sitter, an incremental parsing system.

It aims to be the foundation for a new breed of Emacs packages that understand code structurally. For example:

- Faster, fine-grained code highlighting.
- More flexible code folding.
- Structural editing (like Paredit, or even better) for non-Lisp code.
- More informative indexing for imenu.


#+begin_src emacs-lisp
(use-package tree-sitter-langs)

(use-package tree-sitter
  :defer t
  :init
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
  (global-tree-sitter-mode)
  :custom
  (custom-set-faces
   '(italic ((t nil)))
   '(tree-sitter-hl-face:property ((t (:inherit font-lock-constant-face)))))
  :config
  (setq tree-sitter-debug-jump-buttons t
        tree-sitter-debug-highlight-jump-region t))

(use-package evil-textobj-tree-sitter
  :straight t
  :init
  (define-key evil-outer-text-objects-map "f" (evil-textobj-tree-sitter-get-textobj "function.outer"))
  (define-key evil-inner-text-objects-map "f" (evil-textobj-tree-sitter-get-textobj "function.inner"))
  (define-key evil-outer-text-objects-map "c" (evil-textobj-tree-sitter-get-textobj "comment.outer"))
  (define-key evil-outer-text-objects-map "C" (evil-textobj-tree-sitter-get-textobj "class.outer"))
  (define-key evil-outer-text-objects-map "a" (evil-textobj-tree-sitter-get-textobj ("conditional.outer" "loop.outer"))))
#+end_src

** Async

[[https://github.com/jwiegley/emacs-async][async.el]] is a module for doing asynchronous processing in Emacs. Some async applications are provided as well with this package:

- Dired-async
- smtp-mail-async
- async-bytecomp


#+begin_src emacs-lisp
(use-package async
  :init
  (dired-async-mode 1))
#+end_src

** rg

[[https://github.com/dajva/rg.el][rg.el]] is a replacement for both grep like (search one file) and ag like (search many files) tools.
It's fast and versatile and written in Rust.
For some introduction and benchmarks, see ripgrep is faster than {grep, ag, git grep, ucg, pt, sift}.

#+begin_src emacs-lisp
(use-package rg
  :init
  (rg-enable-default-bindings))
#+end_src


* Git
:PROPERTIES:
:header-args: :tangle init.el
:END:

[[https://magit.vc/][Magit]] is a complete text-based user interface to Git.
It fills the glaring gap between the Git command-line interface and various GUIs,
letting you perform trivial as well as elaborate version control tasks with just a couple of mnemonic key presses.
Magit looks like a prettified version of what you get after running a few Git commands but in Magit every bit of visible information
is also actionable to an extent that goes far beyond what any Git GUI provides and it takes care of automatically refreshing this output when it becomes outdated.
In the background Magit just runs Git commands and if you wish you can see what exactly is being run,
making it possible for you to learn the git command-line by using Magit.

#+begin_src emacs-lisp
(use-package magit
  :general
  (chris/leader-keys
    "g" '(:ignore t :wk "git")
    "gg" '(magit-status :wk "status")
    "gG" '(magit-list-repositories :wk "list repos"))
  :config
  (setq magit-push-always-verify nil)
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  (setq magit-repository-directories
        '(("~/.local/src"  . 2)
          ("~/.config/" . 2)))
  (setq git-commit-summary-max-length 50)
  :bind
  ("C-x g" . magit-status)
  ("C-x C-g" . magit-list-repositories))
#+end_src


* Languages
:PROPERTIES:
:header-args: :tangle init.el
:END:

Some languages modes. Nothing to see here.

** Haskell

#+begin_src emacs-lisp
(use-package haskell-mode
  :config
  (defun chris/haskell-open-repl (&optional arg)
    "Opens a Haskell REPL."
    (interactive "P")
    (if-let (window
             (display-buffer
              (haskell-session-interactive-buffer (haskell-session))))
	(window-buffer window)
      (error "Failed to display Haskell REPL")))
  (add-hook 'haskell-mode-hook
            #'haskell-collapse-mode ; support folding haskell code blocks
  (add-to-list 'completion-ignored-extensions ".hi")))
#+end_src

** Lua

#+begin_src emacs-lisp
(use-package lua-mode
  :config
  (setq lua-indent-level 2)
  (setq lua-electric-flag nil)
  (defun lua-abbrev-mode-off () (abbrev-mode 0))
  (add-hook 'lua-mode-hook 'lua-abbrev-mode-off)
  (setq save-abbrevs nil))
#+end_src

** emmet mode 

#+begin_src emacs-lisp
(use-package emmet-mode
  :config
  (setq emmet-indent-after-insert nil)
  (setq emmet-indentation 2)
  (setq emmet-self-closing-tag-style "/")
  :hook
  (sgml-mode-hook . emmet-mode)
  (css-mode-hook . emmet-mode))
#+end_src

** Php

#+begin_src emacs-lisp
(use-package php-mode
  :config
  (add-hook 'php-mode-hook (lambda ()
           (defun ywb-php-lineup-arglist-intro (langelem)
             (save-excursion
         (goto-char (cdr langelem))
         (vector (+ (current-column) c-basic-offset))))
           (defun ywb-php-lineup-arglist-close (langelem)
             (save-excursion
         (goto-char (cdr langelem))
         (vector (current-column))))
           (c-set-offset 'arglist-intro 'ywb-php-lineup-arglist-intro)
           (c-set-offset 'arglist-close 'ywb-php-lineup-arglist-close))))
#+end_src

** Matlab

The =open-matlab-shell= opens a matlab shell in a split that is 40c high.

#+begin_src emacs-lisp
(straight-use-package 'matlab-mode)
(autoload 'matlab-mode "matlab" "Matlab Editing Mode" t)
(add-to-list
 'auto-mode-alist
 '("\\.m$" . matlab-mode))
(setq matlab-indent-function t)
(setq matlab-shell-command-switches '("-nosplash" "-nodesktop"))
(setq matlab-shell-command "matlab")

(defun open-matlab-shell ()
  (interactive)
  (split-window-below 40)
  (other-window 1)
  (matlab-shell))
#+end_src


* Terminal
:PROPERTIES:
:header-args: :tangle init.el
:END:

This section provides terminal "emulation" for this configuration.

** vterm

Emacs-libvterm ([[https://github.com/akermu/emacs-libvterm][vterm]]) is fully-fledged terminal emulator inside GNU Emacs based on libvterm, a C library.
As a result of using compiled code (instead of elisp), emacs-libvterm is fully capable, fast, and it can seamlessly handle large outputs.

It is important to configure the system shell (in this case bash in the ~.bashrc~):

#+begin_src bash :tangle no
vterm_printf() {
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ]); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_cmd() {
    local vterm_elisp
    vterm_elisp=""
    while [ $# -gt 0 ]; do
        vterm_elisp="$vterm_elisp""$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's|\\|\\\\|g' -e 's|"|\\"|g')")"
        shift
    done
    vterm_printf "51;E$vterm_elisp"
}

find_file() {
    vterm_cmd find-file "$(realpath "${@:-.}")"
}
#+end_src

#+begin_src emacs-lisp
(use-package vterm
  :hook
  (vterm-mode . (lambda () (setq-local global-hl-line-mode nil)))
  :init
  (setq vterm-timer-delay 0.01))
#+end_src

** eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][eshell]] is a shell-like command interpreter implemented in Emacs Lisp.
It invokes no external processes except for those requested by the user.
It is intended to be an alternative to the IELM (see Emacs Lisp Interaction in The Emacs Editor)
REPL for Emacs and with an interface similar to command shells such as bash, zsh, rc, or 4dos. 

#+begin_src emacs-lisp
(defun chris/configure-eshell ()
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)
  (setq eshell-history-size         10000
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t)
  (setq tramp-default-method "ssh"))

(use-package eshell
  :straight (:type built-in)
  :hook
  (eshell-first-time-mode . chris/configure-eshell)
  :config
  (with-eval-after-load 'esh-opt
    (setq eshell-destroy-buffer-when-process-dies t)
    (setq eshell-visual-commands '("ssh" "tail" "htop" "pulsemixer" "top" "nvim" "vim"))))
#+end_src

*** custom functionality

**** Git status

Function to get the git status in magit.

#+begin_src emacs-lisp
(defun eshell/gst (&rest args)
  (magit-status (pop args) nil)
  (eshell/echo))   ;; The echo command suppresses output
#+end_src

**** find

Custom find function.

#+begin_src emacs-lisp
(defun eshell/find (&rest args)
  "Wrapper around the ‘find’ executable."
  (let ((cmd (concat "find " (string-join args))))
    (shell-command-to-string cmd)))
#+end_src

**** clear

Custom clear function.

#+begin_src emacs-lisp
(defun my/eshell/clear ()
  "Clear `eshell' buffer.

   Similar to the behavior of `comint-clear-buffer' in `shell'."
  (interactive)
  (let ((input (eshell-get-old-input)))
    (eshell/clear-scrollback)
    (eshell-emit-prompt)
    (insert input)))

(add-hook 'eshell-mode-hook
          (lambda ()
            (define-key eshell-mode-map "\C-l" 'my/eshell/clear)))
#+end_src

**** mkdir and cd

Function to create a directory and change into the new directory.

#+begin_src emacs-lisp
(defun eshell/mkdir-and-cd (dir)
  "Create a directory then cd into it."
  (make-directory dir t)
  (eshell/cd dir))
#+end_src


* Some other packages
:PROPERTIES:
:header-args: :tangle init.el
:END:

Some other packages that don't really belong anywhere.

** Rainbow mode

Colorize color names in buffers.

#+begin_src emacs-lisp
(use-package rainbow-mode)
#+end_src

** emms

[[https://www.gnu.org/software/emms/][emms]] is the Emacs Multimedia System. Emms displays and plays multimedia from within GNU/Emacs using a variety of external players and from different sources.

Emms can run as a minimalist player and controlled with a handful of M-x Emacs commands, or a fully-fledged, interactive media browser.
Emms can display album art, play streaming audio, tag music files, search for lyrics, provide MPD connectivity, control the volume, and more.


#+begin_src emacs-lisp
(use-package emms
  :general
  (chris/leader-keys
    "m" '(:ignore t :wk "emms")
    "mm" '(emms :wk "emms")
    "mb" '(emms-smart-browse :wk "EMMS Smart Browse")
    "mi" '(emms-show :wk "EMMS show current song")
    "mn" '(emms-next :wk "EMMS next song")
    "mp" '(emms-previous :wk "EMMS previous song")
    "ml" '(emms-seek-forward :wk "EMMS go 10s forward")
    "mt" '(emms-toggle-repeat-track :wk "EMMS toggle repeat")
    "mh" '(emms-seek-backward :wk "EMMS go 10s backward")))
(require 'emms-setup)
(emms-all)
(emms-default-players)
(emms-mode-line 0)
(emms-playing-time 1)
(setq emms-source-file-default-directory "~/Music/"
      emms-playlist-buffer-name "*Music*"
      emms-info-asynchronously t
      emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
#+end_src

** org-tree-slide

[[https://github.com/takaxp/org-tree-slide][org-tree-slide]] is a presentation tool for org-mode based on the visibility of outline trees.

#+begin_src emacs-lisp
(use-package org-tree-slide
  :custom
  (org-tree-slide-breadcrumbs nil)
  (org-tree-slide-header nil)
  (org-tree-slide-in-effect nil)
  (org-tree-slide-slide-in-effect nil)
  (org-tree-slide-heading-emphasis nil)
  (org-tree-slide-cursor-init t)
  (org-tree-slide-never-touch-face t)
  :config
  (defun chris/org-presentation ()
    "Specifies conditions that should apply locally upon activation
of `org-tree-slide-mode'."
    (if (eq org-tree-slide-mode nil)
	(progn
          (chris/olivetti-mode -1)
          (fontaine-set-preset 'regular))
      (chris/olivetti-mode)
      (fontaine-set-preset 'presentation)))
  :hook
  (org-tree-slide-mode . chris/org-presentation)
  )
#+end_src

** pdf-tools

#+begin_src emacs-lisp
(use-package pdf-tools
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page))
#+end_src
