#+title: Emacs Configuration
#+author: Christian Hageloch
#+startup: overview

Currently tailored for GNU Emacs 28.2.

* Early init file
:PROPERTIES:
:header-args: :tangle early-init.el
:END:

~straight.el~ is used as the package management system.
To prevent ~package.el~ from loading packages and garbage-collection:

#+begin_src emacs-lisp
;;; early-init.el --- Early Init File -*- lexical-binding: t; no-byte-compile: t -*-
(setq gc-cons-threshold (* 100 1024 1024))
(setq package-enable-at-startup nil)
#+end_src

Disable gui elements:

#+begin_src emacs-lisp
(defun chris/toggle-gui-elements (&optional on-off)
  "Toggle menu bar, tool bar, scroll bars, and tool tip modes. If
  optional ON-OFF is not specified, then toggle on/off state. If
  ON-OFF is 0 or 1, then turn gui elements OFF or ON respectively."
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode (or on-off (not scroll-bar-mode))))
  (when  (fboundp 'tool-bar-mode)
    (tool-bar-mode (or on-off (not tool-bar-mode))))
  (unless (memq (window-system) '(mac ns))
    (when (fboundp 'menu-bar-mode)
      (menu-bar-mode (or on-off (not menu-bar-mode)))))
  ;; tooltips in echo-aera
  (when (fboundp 'tooltip-mode)
    (tooltip-mode (or on-off (not tooltip-mode)))))

(chris/toggle-gui-elements 0)

(setq inhibit-splash-screen t
      use-file-dialog nil)
#+end_src


* Package management
:PROPERTIES:
:header-args: :tangle init.el
:END:

** ~init.el~ header

#+begin_src emacs-lisp
;;; init.el --- Personal configuration file -*- lexical-binding: t; no-byte-compile: t; -*-
#+end_src

** straight.el

[[https://github.com/raxod502/straight.el][GitHub - radian-software/straight.el]]

Some rules/conventions:

- When packages don't require installation, use ~:straight (:type built-in)~.
- Prefer multiple ~setq~ expressions to one.
- Prefer ~:init~ to ~:custom~.

** Bootstrap ~straight.el~

#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
	(url-retrieve-synchronously
	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
	 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package)
#+end_src


* Emacs
:PROPERTIES:
:header-args: :tangle init.el
:END:

** General configuration options

#+begin_src emacs-lisp
(use-package emacs
  :straight (:type built-in)
  :config
  (setq user-full-name "Christian Hageloch")
  (setq use-short-answers t)
  (setq indent-tabs-mode nil)
  (setq blink-cursor-mode nil)
  (setq make-backup-files nil)
  (setq auto-save-default nil)
  (setq backup-directory-alist
	`((".*" . ,(concat user-emacs-directory "backups")))
	auto-save-file-name-transforms
	`((".*" ,(concat user-emacs-directory "backups") t)))
  (setq create-lockfiles nil)
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (setq display-line-numbers-type 'relative)
  (column-number-mode)
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq find-file-visit-truename t)
  (set-default-coding-systems 'utf-8)
  :init
  (setq completion-cycle-threshold 3)
  (setq tab-always-indent 'complete))
#+end_src

** Reload configuration

#+begin_src emacs-lisp
(defun chris/config-reload ()
  "Reload the configuration file"
  (interactive)
  (load-file (expand-file-name "~/.emacs.d/init.el")))
#+end_src

** Electric

#+begin_src emacs-lisp
(use-package electric
  :straight (:type built-in)
  :config
  (setq electric-pair-pairs '(
			     (?\{ . ?\})
			     (?\( . ?\))
			     (?\[ . ?\])
			     (?\" . ?\")
			     ))
  :init
  (electric-pair-mode t))
#+end_src


* Keybindings
:PROPERTIES:
:header-args: :tangle init.el
:END:

** General

*** General setup

#+begin_src emacs-lisp
(use-package general
  :config
  ;; integrate general with evil
  (general-evil-setup)
  ;; set up 'SPC' as the global leader key
  (general-create-definer chris/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "M-SPC") ;; access leader in insert mode

  ;; set up ',' as the local leader key
  (general-create-definer chris/local-leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "," ;; set local leader
    :global-prefix "M-,") ;; access local leader in insert mode

  (general-define-key
   :states 'insert
   "C-g" 'evil-normal-state) ;; don't stretch for ESC

  ;; unbind some annoying default bindings
  (general-unbind
    "C-x C-r"	;; unbind find file read only
    "C-x C-z"	;; unbind suspend frame
    "C-x C-d"	;; unbind list directory
    "<mouse-2>") ;; pasting with mouse wheel click

  (chris/leader-keys
    "SPC" '(counsel-M-x :wk "M-x"))) ;; an alternative to 'M-x'
#+end_src

*** Keybindings for files

#+begin_src emacs-lisp
(chris/leader-keys
  "f" '(:ignore t :wk "file")
  "ff" '(counsel-find-file :wk "find file")
  "fz" '(counsel-fzf :wk "fuzzy finder")
  "fg" '(counsel-grep :wk "fuzzy finder (grep)")
  "fr" '(counsel-recentf :wk "Recent files")
  "fs" '(save-buffer :wk "Save file")
  "fu" '(sudo-edit-find-file :wk "Sudo find file")
  "fC" '(copy-file :wk "Copy file")
  "fD" '(delete-file :wk "Delete file")
  "fR" '(rename-file :wk "Rename file")
  "fS" '(write-file :wk "Save file as...")
  "fU" '(sudo-edit :wk "Sudo edit file"))
#+end_src

*** Keybindings for buffers

#+begin_src emacs-lisp
(chris/leader-keys
  "b" '(:ignore t :wk "buffer")
  "bi" '(ibuffer :wk "ibuffer")
  "bb" '(ivy-switch-buffer :wk "switch buffer")
  "bf" '(chris/toggle-maximize-buffer :wk "Toggle maximize buffer")
  "bc" '(clone-indirect-buffer-other-window :wk "Clone indirect buffer other window")
  "bk" '(kill-current-buffer :wk "Kill current buffer")
  "bv" '(chris/buffers-vc-root :wk "Buffers in project root") 
  "bm" '(chris/buffers-major-mode :wk "Buffers with same major mode")
  "bn" '(next-buffer :wk "Next buffer")
  "bp" '(previous-buffer :wk "Previous buffer")
  "bB" '(ibuffer-list-buffers :wk "Ibuffer list buffers")
  "br" '(revert-buffer :wk "Revert Buffer")
  "bs" '(chris/simple-scratch-buffer :wk "Revert Buffer")
  "bK" '(chris/kill-buffer-and-close-split :wk "Kill buffer"))
#+end_src

*** Keybindings to toggle things

#+begin_src emacs-lisp
(chris/leader-keys
  "t"  '(:ignore t :wk "toggle")
  "tr" '(chris/config-reload :wk "config")
  "tl" '(chris/toggle-line-numbers :wk "linenumbers")
  "ts" '(chris/tab-status-line :wk "tab-bar-line")
  "tt" '(modus-themes-toggle :wk "theme")
  "tc" '(chris/toggle-code :wk "code"))
#+end_src

*** Keybindings to open programs within Emacs

#+begin_src emacs-lisp
(chris/leader-keys
  "o" '(:ignore t :wk "open")
  "ot" '(vterm :wk "vterm")
  "oe" '(eshell :wk "eshell")
  "op" '(list-processes :wk "get a list of processes")
  "os" '(fontaine-set-preset :wk "fontaine")
  "ol" '(org-toggle-link-display :wk "Display org links")
  "oc" '(org-capture :wk "org campture")
  "oa" '(org-agenda :wk "org campture")
  "oo" '(occur "^*+" :wk "org sidebar")
  "ob" '(bluetooth-list-devices :wk "List bluetooth devices")
  "oi" '(chris/nmcli-wifi-preexist :wk "internet preexisting")
  "oI" '(chris/nmcli-wifi :wk "Connect wifi")
  )
#+end_src

*** Keybindings for code

#+begin_src emacs-lisp
(chris/leader-keys
  "c" '(:ignore t :wk "code-action")
  "cc" '(compile :wk "Compile"))
#+end_src

** Hydra

#+begin_src emacs-lisp
(use-package hydra
  :defer t
  :config
  ;; scale text
  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

  ;; split size
  (defhydra hydra-split-size (:timeout 4)
    "increase/decrease split size"
    ("h" shrink-window-horizontally)
    ("j" enlarge-window)
    ("k" shrink-window)
    ("l" enlarge-window-horizontally)
    ("n" balance-windows)
    ("f" nil "finished" :exit t))

  :general
  (chris/leader-keys
    "h" '(:ignore t :wk "hydra")
    "hf" '(hydra-text-scale/body :wk "scale text")
    "hs" '(hydra-split-size/body :wk "split size")))
#+end_src

** Evil

*** General evil setup

#+begin_src emacs-lisp
(use-package evil
  :general
  (chris/leader-keys
    "w" '(:keymap evil-window-map :wk "window")) ;; window bindings
  :init
  (setq evil-search-module 'isearch)

  (setq evil-want-C-u-scroll t) ;; allow scroll up with 'C-u'
  (setq evil-want-C-d-scroll t) ;; allow scroll down with 'C-d'

  (setq evil-want-integration t) ;; necessary for evil collection
  (setq evil-want-keybinding nil)

  (setq evil-split-window-below t)
  (setq evil-vsplit-window-right nil)

  ;; cursors
  (setq evil-normal-state-cursor 'box)
  (setq evil-insert-state-cursor 'box)
  (setq evil-visual-state-cursor 'box)
  (setq evil-motion-state-cursor 'box)
  (setq evil-replace-state-cursor 'box)
  (setq evil-operator-state-cursor 'box)

  (setq evil-want-C-i-jump nil) ;; hopefully this will fix weird tab behaviour

  (setq evil-undo-system 'undo-redo) ;; undo via 'u', and redo the undone change via 'C-r'; only available in emacs 28+.
  :config
  (evil-mode t) ;; globally enable evil mode
  ;; set the initial state for some kinds of buffers.
  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal)
  ;; buffers in which I want to immediately start typing should be in 'insert' state by default.
  (evil-set-initial-state 'eshell-mode 'insert)
  (evil-set-initial-state 'magit-diff-mode 'insert))
#+end_src

*** Evil collection

#+begin_src emacs-lisp
(use-package evil-collection ;; evilifies a bunch of things
  :after evil
  :init
  (setq evil-collection-outline-bind-tab-p t) ;; '<TAB>' cycles visibility in 'outline-minor-mode'
  ;; If I want to incrementally enable evil-collection mode-by-mode, I can do something like the following:
  ;; (setq evil-collection-mode-list nil) ;; I don't like surprises
  ;; (add-to-list 'evil-collection-mode-list 'magit) ;; evilify magit
  ;; (add-to-list 'evil-collection-mode-list '(pdf pdf-view)) ;; evilify pdf-view
  :config
  (evil-collection-init))
#+end_src

*** Evil commentary

#+begin_src emacs-lisp
(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode)) ;; globally enable evil-commentary
#+end_src

*** C-d and C-u

#+begin_src emacs-lisp
(defun chris/scroll-down-and-center ()
"Scroll down and center the text to the screen"
  (interactive)
  (evil-scroll-down 0)
  (evil-scroll-line-to-center (line-number-at-pos)))

(define-key evil-motion-state-map "\C-d" 'chris/scroll-down-and-center)

(defun chris/scroll-up-and-center ()
"Scroll up and center the text to the screen"
  (interactive)
  (evil-scroll-up 0)
  (evil-scroll-line-to-center (line-number-at-pos)))

(define-key evil-motion-state-map "\C-u" 'chris/scroll-up-and-center)
#+end_src

** Whichkey

#+begin_src emacs-lisp
(use-package which-key
  :init
  (which-key-mode)
  :config
  (which-key-setup-minibuffer))
#+end_src


* Org-mode
:PROPERTIES:
:header-args: :tangle init.el
:END:

** General org-mode setup

#+begin_src emacs-lisp
(use-package org
  :straight (:type built-in)
  :config
  (setq org-ellipsis " ")
  (setq orc-src-fontify-natively t)
  (setq src-tab-acts-natively t)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-block-delimiter-line t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (setq org-hide-emphasis-markers t)
  (setq org-src-preserve-indentation 1)
  (setq org-edit-src-content-indentation 0)

  ;; configure babel languages
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (shell . t)))

    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))

    (push '("conf-unix" . conf-unix) org-src-lang-modes))

  (setq org-directory "~/org")
  (setq org-default-notes-file (concat org-directory "/notes.org")))
#+end_src

** Org-agenda

#+begin_src emacs-lisp
(setq org-agenda-files '("~/org/Agenda.org"))
(setq org-agenda-start-with-log-mode t)
(setq org-log-done 'time)
(setq org-log-into-drawer t)
(setq org-log-done 'time)
#+end_src

** denote

Not really specific to org mode but by default it is.

#+begin_src emacs-lisp
(use-package denote
  :config
  (setq denote-directory (expand-file-name "~/notes/"))
  (setq denote-known-keywords '("emacs" "programming" "administration" "linux"))
  :hook
  (dired-mode . denote-dired-mode)
  (dired-mode . dired-hide-details-mode))
#+end_src


* Appearance
:PROPERTIES:
:header-args: :tangle init.el
:END:

** Fonts

#+begin_src emacs-lisp  
(use-package fontaine
  :config
  (setq x-underline-at-descent-line t)
  (setq-default text-scale-remap-header-line t)
  (fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular))
  :init
  (setq fontaine-presets
      '((regular
         :default-height 140)
        (medium
         :default-weight semilight
         :default-height 180)
        (large
         :default-weight semilight
         :default-height 200 
         :bold-weight extrabold)
        (t
         ;; :default-family "Iosevka Comfy Wide Fixed"
         :default-family "Terminus"
         :default-weight normal
         ;; :default-height 100
         :fixed-pitch-family nil ; falls back to :default-family
         :fixed-pitch-weight nil ; falls back to :default-weight
         :fixed-pitch-height 1.0
         ;; :variable-pitch-family "Iosevka Comfy Duo"
         :variable-pitch-family "Terminus"
         :variable-pitch-weight normal
         :variable-pitch-height 1.05
         :bold-family nil ; use whatever the underlying face has
         :bold-weight bold
         :italic-family nil
         :italic-slant italic
         :line-spacing nil))))
#+end_src

** Theme

#+begin_src emacs-lisp
(use-package modus-themes
  :config
  (setq modus-themes-bold-constructs t
        modus-themes-italic-construct nil
        modus-themes-common-palette-overrides
        '(
	  (comment yellow-faint)
	  (string green-faint)
	  (prose-done green-faint)
	  (prose-todo red-faint)
          (border-mode-line-active unspecified)
          (border-mode-line-inactive unspecified)
          (fringe unspecified))
        modus-themes-headings
        '((1 . (1.3))
          (2 . (1.2))
          (3 . (1.1))
          (t . (1.0)))))

(if (string-match
     "modus-vivendi"
     (shell-command-to-string "cat ~/.config/bspwm/active-theme"))
    (modus-themes-load-theme 'modus-vivendi)
  (modus-themes-load-theme 'modus-operandi))
#+end_src

** Modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :config
  (setq doom-modeline-height 28)
  :init
  (doom-modeline-mode 1))
#+end_src


* Completion 
:PROPERTIES:
:header-args: :tangle init.el
:END:

#+begin_src emacs-lisp
(use-package ivy
  :bind
  ("C-s" . swiper)
  :init
  (ivy-mode))

(use-package counsel
  :config
  (setq counsel-switch-buffer-preview-virtual-buffers nil)
  :init
  (counsel-mode))

(use-package savehist
  :straight (:type built-in)
  :config
  (setq history-length 25)
  :init
  (savehist-mode))
#+end_src



* File management
:PROPERTIES:
:header-args: :tangle init.el
:END:

** Dired

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :general
  (chris/leader-keys
    "d" '(:ignore t :wk "dired")
    "dd" '(dired :wk "Open Dired")
    "dj" '(dired-jump :wk "Jump to current directory in dired"))
  :config
  (put 'dired-find-alternate-file 'disabled nil))
#+end_src

** Sudo Edit

#+begin_src emacs-lisp
(use-package sudo-edit)
#+end_src

** Calendar

#+begin_src emacs-lisp
(setq calendar-week-start-day 1
      calendar-day-name-array ["Sonntag" "Montag" "Dienstag" "Mittwoch"
			       "Donnerstag" "Freitag" "Samstag"]
      calendar-month-name-array ["Januar" "Februar" "März" "April" "Mai"
				 "Juni" "Juli" "August" "September"
				 "Oktober" "November" "Dezember"])
(setq solar-n-hemi-seasons
      '("Frühlingsanfang" "Sommeranfang" "Herbstanfang" "Winteranfang"))

(setq holiday-general-holidays
      '((holiday-fixed 1 1 "Neujahr")
        (holiday-fixed 5 1 "1. Mai")
        (holiday-fixed 10 3 "Tag der Deutschen Einheit")))

;; Feiertage für Bayern, weitere auskommentiert
(setq holiday-christian-holidays
      '((holiday-float 12 0 -4 "1. Advent" 24)
        (holiday-float 12 0 -3 "2. Advent" 24)
        (holiday-float 12 0 -2 "3. Advent" 24)
        (holiday-float 12 0 -1 "4. Advent" 24)
        (holiday-fixed 12 25 "1. Weihnachtstag")
        (holiday-fixed 12 26 "2. Weihnachtstag")
        (holiday-fixed 1 6 "Heilige Drei Könige")
        (holiday-easter-etc -48 "Rosenmontag")
        ;; (holiday-easter-etc -3 "Gründonnerstag")
        (holiday-easter-etc  -2 "Karfreitag")
        (holiday-easter-etc   0 "Ostersonntag")
        (holiday-easter-etc  +1 "Ostermontag")
        (holiday-easter-etc +39 "Christi Himmelfahrt")
        (holiday-easter-etc +49 "Pfingstsonntag")
        (holiday-easter-etc +50 "Pfingstmontag")
        (holiday-easter-etc +60 "Fronleichnam")
        (holiday-fixed 8 15 "Mariae Himmelfahrt")
        (holiday-fixed 11 1 "Allerheiligen")
        ;; (holiday-float 11 3 1 "Buss- und Bettag" 16)
        (holiday-float 11 0 1 "Totensonntag" 20)))

(setq calendar-holidays holiday-christian-holidays)
#+end_src


* Buffer management
:PROPERTIES:
:header-args: :tangle init.el
:END:

** Popper

#+begin_src emacs-lisp
(use-package popper
  :ensure t ; or :straight t
  :bind (("C-`"   . popper-toggle-latest)
	 ("M-`"   . popper-cycle)
	 ("C-M-`" . popper-toggle-type))
  :general
  (chris/leader-keys
    "u" '(:ignore t :wk "popper")
    "ut" '(popper-toggle-latest :wk "toggle latest")
    "uc" '(popper-cycle :wk "cycle")
    "up" '(popper-toggle-type :wk "toggle type (promote)"))
  :config
  (setq popper-mode-line nil)
  :init
  (setq popper-reference-buffers
	'("\\*Messages\\*"
	  "Output\\*$"
	  "\\*Async Shell Command\\*"
	  "^\\*MATLAB\\*$"
	  "^\\*Racket REPL.*\\*$"
	  "^\\*lua\\*$"
	  "^\\*Python\\*$"
	  "^\\*Process List\\*$"
	  "^\\*Flycheck \\*"
	  help-mode
	  compilation-mode))
  (popper-mode +1)
  (popper-echo-mode +1))                ; For echo area hints
#+end_src

** Get all buffers with the same major mode as the current file

#+begin_src emacs-lisp
(defun chris/buffers-major-mode (&optional arg)
  "Select buffers that match the current buffer's major mode.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly.  Else use standard completion."
  (interactive "P")
  (let* ((major major-mode)
	 (prompt "Buffers for ")
	 (mode-string (format "%s" major))
	 (mode-string-pretty (propertize mode-string 'face 'success)))
    (if arg
	(ibuffer t (concat "*" prompt mode-string "*")
		 (list (cons 'used-mode major)))
      (switch-to-buffer
       (read-buffer
	(concat prompt mode-string-pretty ": ") nil t
	(lambda (pair) ; pair is (name-string . buffer-object)
	  (with-current-buffer (cdr pair) (derived-mode-p major))))))))
#+end_src

** Get all buffers in current project (vc-root)

#+begin_src emacs-lisp
(defun chris/buffers-vc-root (&optional arg)
  "Select buffers that match the present `vc-root-dir'.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly.  Else use standard completion.

When no VC root is available, use standard `switch-to-buffer'."
  (interactive "P")
  (let* ((root (vc-root-dir))
         (prompt "Buffers for VC ")
         (vc-string (format "%s" root))
         (vc-string-pretty (propertize vc-string 'face 'success)))
    (if root
        (if arg
            (ibuffer t (concat "*" prompt vc-string "*")
                     (list (cons 'filename (expand-file-name root))))
          (switch-to-buffer
           (read-buffer
            (concat prompt vc-string-pretty ": ") nil t
            (lambda (pair) ; pair is (name-string . buffer-object)
              (with-current-buffer (cdr pair) (string= (vc-root-dir) root))))))
      (call-interactively 'switch-to-buffer))))
#+end_src

** Maximize a buffer

#+begin_src emacs-lisp
(defun chris/toggle-maximize-buffer ()
  "Maximize buffer"
  (interactive)
  (if (= 1 (length (window-list)))
      (jump-to-register '_) 
    (progn
      (window-configuration-to-register '_)
      (delete-other-windows))))
#+end_src

** Kill a buffer and close the split

#+begin_src emacs-lisp
(defun chris/kill-buffer-and-close-split ()
  "Kill buffer and close split"
  (interactive)
  (kill-current-buffer)
  (evil-window-delete))
#+end_src

** Kill all dired buffers

#+begin_src emacs-lisp
(defun chris/kill-dired-buffers ()
  "Kill all open dired buffers."
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))
#+end_src

** Create custom scratch buffers

#+begin_src emacs-lisp
;;; Generic setup
(defun chris/simple--scratch-list-modes ()
  "List known major modes."
  (cl-loop for sym the symbols of obarray
           when (and (functionp sym)
                     (provided-mode-derived-p sym 'prog-mode))
           collect sym))

(defun chris/simple--scratch-buffer-setup (region &optional mode)
  "Add contents to `scratch' buffer and name it accordingly.

REGION is added to the contents to the new buffer.

Use the current buffer's major mode by default.  With optional
MODE use that major mode instead."
  (let* ((major (or mode major-mode))
         (string (format "Scratch buffer for: %s\n\n" major))
         (text (concat string region))
         (buf (format "*Scratch for %s*" major)))
    (with-current-buffer (get-buffer-create buf)
      (funcall major)
      (save-excursion
        (insert text)
        (goto-char (point-min))
        (comment-region (point-at-bol) (point-at-eol))))
    (switch-to-buffer buf)))

(defun chris/simple-scratch-buffer (&optional arg)
  "Produce a bespoke scratch buffer matching current major mode.

If the major-mode is not derived from 'prog-mode, it prompts for
a list of all derived prog-modes AND org-mode

If region is active, copy its contents to the new scratch
buffer."
  (interactive "P")
  (let* ((modes (chris/simple--scratch-list-modes))
         (region (with-current-buffer (current-buffer)
                   (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning)
                        (region-end))
                     "")))
         (m))
    (if (derived-mode-p 'prog-mode)
        (chris/simple--scratch-buffer-setup region)
      (progn
	(setq m (intern (completing-read "Select major mode: " modes nil t)))
	(chris/simple--scratch-buffer-setup region m)))))
#+end_src

** Toggle line numbers

#+begin_src emacs-lisp
(defun chris/toggle-line-numbers ()
  "Toggles the display of line numbers."
  (interactive)
  (if (bound-and-true-p display-line-numbers-mode)
      (global-display-line-numbers-mode -1)
    (global-display-line-numbers-mode)))
#+end_src


* Desktop environment (kindof)
:PROPERTIES:
:header-args: :tangle init.el
:END:

** Internet 

Display a table of all pre configured internet connections.

#+begin_src emacs-lisp
(define-derived-mode chris/nmcli-wifi-preexist-mode tabulated-list-mode
  "nmcli-wifi-preexist"
  "nmcli preexisting WiFi Mode"
  (let ((columns [("NAME" 20 t)
                  ("UUID" 40 t)
                  ("TYPE" 10 t)
                  ("DEVICE" 10 t)])
        (rows (chris/nmcli-wifi-preexist--shell-command)))
    (setq tabulated-list-format columns)
    (setq tabulated-list-entries rows)
    (tabulated-list-init-header)
    (tabulated-list-print)))

(defun chris/nmcli-wifi-preexist-refresh ()
  "Refresh wifi table."
  (interactive)
  (let ((rows (chris/nmcli-wifi-preexist--shell-command)))
    (setq tabulated-list-entries rows)
    (tabulated-list-print t t)))

(defun chris/nmcli-wifi-preexist-sentinel (process event)
  (cond ((string-match-p "finished" event)
	 (chris/nmcli-wifi-preexist-refresh)
	 (kill-buffer "*async nmcli*"))))

(defun chris/nmcli-wifi-preexist--shell-command ()
  "Shell command to check for preconfigured wifi connections"
  (interactive)
  (mapcar (lambda (x)
	    `(,(car (cdr x))
	      ,(vconcat [] x)))
          (mapcar (lambda (x)
		    x)
		  (cdr (mapcar (lambda (x)
				 (split-string x "  " t " "))
			       (split-string (shell-command-to-string "nmcli connection") "\n" t))))))

(defun chris/nmcli-wifi-preexist ()
  "Menu for (dis)connecting from preexisting wifi connections."
  (interactive)
  (switch-to-buffer "*nmcli-wifi-preexist*")
  (chris/nmcli-wifi-preexist-mode))

(defun chris/nmcli-wifi-preexist-connect ()
  "Connect to wifi."
  (interactive)
  (let* ((ssid (aref (tabulated-list-get-entry) 1))
	 (process (start-process-shell-command "nmcli" "*async nmcli*" (format "nmcli connection up \"%s\"" ssid))))
    (set-process-sentinel process 'chris/nmcli-wifi-preexist-sentinel)))

(defun chris/nmcli-wifi-preexist-disconnect ()
  "Disconnect from wifi."
  (interactive)
  (let* ((ssid (aref (tabulated-list-get-entry) 1))
	 (process (start-process-shell-command "nmcli" "*async nmcli*" (format "nmcli connection down \"%s\"" ssid))))
    (set-process-sentinel process 'chris/nmcli-wifi-preexist-sentinel)))

(general-define-key
 :states 'normal
 :keymaps 'chris/nmcli-wifi-preexist-mode-map
 "c" '(chris/nmcli-wifi-preexist-connect :wk "connect")
 "d" '(chris/nmcli-wifi-preexist-disconnect :wk "disconnect")
 "r" '(chris/nmcli-wifi-preexist-refresh :wk "refresh"))

(add-to-list 'display-buffer-alist
	     (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))
#+end_src

** Bluetooth

#+begin_src emacs-lisp
(defun chris/bluetooth-sentinel (process event)
  (message (concat "bluetooth: " event)))

(defun chris/bluetooth-connect-soundcore ()
  "Connect to bluetooth in-ears."
  (interactive)
  (let* ((process (start-process-shell-command
		  "bluetoothctl"
		  nil
		  "bluetoothctl power on && bluetoothctl connect E8:EE:CC:00:AD:24")))
    (set-process-sentinel process 'chris/bluetooth-sentinel)))

(defun chris/bluetooth-disconnect-soundcore ()
  "Disconnect from bluetooth in-ears."
  (interactive)
  (let* ((process (start-process-shell-command
		   "bluetoothctl"
		   nil
		   "bluetoothctl disconnect E8:EE:CC:00:AD:24 && bluetoothctl power off")))
    (set-process-sentinel process 'chris/bluetooth-sentinel)))

(chris/leader-keys
  "a" '(:ignore t :wk "audio")
  "ac" '(chris/bluetooth-connect-soundcore :wk "bluetooth connect")
  "ad" '(chris/bluetooth-disconnect-soundcore :wk "bluetooth disconnect"))
#+end_src


* Projectile
:PROPERTIES:
:header-args: :tangle init.el
:END:

#+begin_src emacs-lisp
(use-package projectile
  :general
  (chris/leader-keys "p" '(:keymap projectile-command-map :wk "projectile"))
  :init
  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (add-to-list 'projectile-globally-ignored-modes "org-mode"))
(setq projectile-indexing-method 'hybrid)

(use-package ibuffer-projectile
  :config 
  (add-hook 'ibuffer-hook
            (lambda ()
              (ibuffer-projectile-set-filter-groups)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic)))))
#+end_src


* Workspaces
:PROPERTIES:
:header-args: :tangle init.el
:END:

** General =tab-bar.el= setup

#+begin_src emacs-lisp
(use-package tab-bar
  :straight (:type built-in)
  :general
  (chris/leader-keys
    "i" '(:keymap tab-prefix-map :wk "tab")
    "is" '(chris/tab-bar-select-tab-dwim :wk "tab-select")
    "ic" '(tab-close :wk "tab-close"))
  :config
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-new-button-show nil)
  (setq tab-bar-forward-button-show nil)
  (setq tab-bar-backward-button-show nil)
  (setq tab-bar-close-last-tab-choice nil)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-current)
  (setq tab-bar-show nil)
  (tab-bar-history-mode 1))
#+end_src

** Manage tabs

#+begin_src emacs-lisp
(defun chris/tab-bar-select-tab-dwim ()
  "Do-What-I-Mean function for getting to a `tab-bar-mode' tab.
If no other tab exists, create one and switch to it.  If there is
one other tab (so two in total) switch to it without further
questions.  Else use completion to select the tab to switch to."
  (interactive)
  (let ((tabs (mapcar (lambda (tab)
                        (alist-get 'name tab))
                      (tab-bar--tabs-recent))))
    (cond ((eq tabs nil)
           (tab-new))
          ((eq (length tabs) 1)
           (tab-next))
          (t
           (tab-bar-switch-to-tab
            (completing-read "Select tab: " tabs nil t))))))
#+end_src


* IDE Features
:PROPERTIES:
:header-args: :tangle init.el
:END:

** Completion ([[http://company-mode.github.io/][company]])

#+begin_src emacs-lisp
(use-package company
  :config
  (setq company-idle-delay 0)
  (setq company-minium-prefix-length 3)
  (setq company-format-margin-function nil)
  :init
  (global-company-mode 1))
#+end_src

** Lsp 

#+begin_src emacs-lisp
(use-package lsp-mode
  :config
  (setq read-process-output-max (* 1024 1024))
  (setq lsp-idle-delay 0.500)
  (setq lsp-log-io nil)
  (setq lsp-enable-links nil)
  (setq lsp-signature-render-documentation nil)
  (setq lsp-headerline-breadcrumb-enable nil)
  (setq lsp-ui-doc-enable nil)
  (setq lsp-completion-enable-additional-text-edit nil)
  (setq lsp-modeline-diagnostics-scope :workspace)
  :init
  (setq lsp-keep-workspace-alive nil)
  (setq lsp-keymap-prefix "C-c l")
  :hook
  (lsp-mode . lsp-enable-which-key-integration)
  (lsp-mode . flycheck-mode)
  :commands
  (lsp lsp-deferred))

(use-package flycheck
  :general
  (chris/leader-keys
    "cd" '(list-flycheck-errors :wk "List flycheck errors")))
#+end_src

** "Code mode"

#+begin_src emacs-lisp
(defun chris/toggle-code ()
  "Toggle on line numbers and hl-line-mode for a better code experience"
  (interactive)
  (if (bound-and-true-p display-line-numbers-mode)
      (display-line-numbers-mode -1)
    (display-line-numbers-mode))
  (if (bound-and-true-p hl-line-mode)
      (hl-line-mode -1)
    (hl-line-mode)))
#+end_src

** Snippets

#+begin_src emacs-lisp
(use-package yasnippet
  :init
  (yas-global-mode 1))

(use-package yasnippet-snippets
  :after yasnippet)
#+end_src

** Treesitter

#+begin_src emacs-lisp
(use-package tree-sitter-langs)

(use-package tree-sitter
  :defer t
  :init
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
  (global-tree-sitter-mode)
  :custom
  (custom-set-faces
   '(italic ((t nil)))
   '(tree-sitter-hl-face:property ((t (:inherit font-lock-constant-face)))))
  :config
  (setq tree-sitter-debug-jump-buttons t
        tree-sitter-debug-highlight-jump-region t))

(use-package evil-textobj-tree-sitter
  :straight t
  :init
  (define-key evil-outer-text-objects-map "f" (evil-textobj-tree-sitter-get-textobj "function.outer"))
  (define-key evil-inner-text-objects-map "f" (evil-textobj-tree-sitter-get-textobj "function.inner"))
  (define-key evil-outer-text-objects-map "c" (evil-textobj-tree-sitter-get-textobj "comment.outer"))
  (define-key evil-outer-text-objects-map "C" (evil-textobj-tree-sitter-get-textobj "class.outer"))
  (define-key evil-outer-text-objects-map "a" (evil-textobj-tree-sitter-get-textobj ("conditional.outer" "loop.outer"))))
#+end_src

** Async

#+begin_src emacs-lisp
(use-package async
  :init
  (dired-async-mode 1))
#+end_src

** rg

#+begin_src emacs-lisp
(use-package rg
  :init
  (rg-enable-default-bindings))
#+end_src

** hl-todo

#+begin_src emacs-lisp
(use-package hl-todo
  :hook
  (prog-mode . hl-todo-mode))
#+end_src


* Languages
:PROPERTIES:
:header-args: :tangle init.el
:END:

** Haskell

#+begin_src emacs-lisp
(use-package haskell-mode
  :mode ("\\.hs\\'" . haskell-mode)
  :config
  (defun haskell-evil-open-above ()
    (interactive)
    (evil-beginning-of-line)
    (haskell-indentation-newline-and-indent)
    (evil-previous-line)
    (haskell-indentation-indent-line)
    (evil-append-line nil))

  (defun haskell-evil-open-below ()
    (interactive)
    (evil-append-line nil)
    (haskell-indentation-newline-and-indent))
  
  (evil-define-key 'normal haskell-mode-map
    "o" 'haskell-evil-open-below
    "O" 'haskell-evil-open-above)
  )
#+end_src

** Lua

#+begin_src emacs-lisp
(use-package lua-mode
  :mode ("\\.lua\\'". lua-mode)
  :interpreter ("lua" . lua-mode)
  :config
  (defun chris/open-lua-repl ()
    "open lua repl in horizontal split"
    (interactive)
    ;; (split-window-horizontally)
    (lua-show-process-buffer))
  :init
  (setq lua-indent-level 4
	lua-indent-string-contents t)
  ;; :hook
  ;; (lua-mode . lsp-deferred)
  :general
  (chris/leader-keys
    "cl" '(chris/open-lua-repl :wk "run-lua"))
  (chris/leader-keys
    :keymaps 'lua-mode-map
    "lr" 'lua-send-buffer))
#+end_src

** python

#+begin_src emacs-lisp
(use-package python-mode
  :straight (:type built-in)
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python3" . python-mode)
  :init
  (setq python-indent 4)
  :general
  (chris/leader-keys
    :keymaps 'python-mode-map
    "cp" 'run-python)
  (chris/leader-keys
    "pr" 'python-shell-send-buffer))

(use-package lsp-pyright
  :hook (python-mode . (lambda ()
			 (require 'lsp-pyright)
			 (lsp-deferred))))
#+end_src

** php

#+begin_src emacs-lisp
(use-package php-mode
  :mode ("\\.php\\'" . php-mode))
#+end_src

** racket

#+begin_src emacs-lisp
(use-package racket-mode
  :interpreter ("racket" . racket-mode)
  :config
  (defun chris/racket-run-and-switch-to-repl ()
    "Call `racket-run-and-switch-to-repl' and enable insert state"
    (interactive)
    (racket-run-and-switch-to-repl)
    (when (buffer-live-p (get-buffer racket-repl-buffer-name))
      (with-current-buffer racket-repl-buffer-name
	(evil-insert-state))))
  :general
  (chris/leader-keys
    "cr" '(racket-repl :wk "run racket and switch to repl"))
  (chris/leader-keys
    :keymaps 'racket-mode-map
    "rs" '(racket-send-last-sexp :wk "racket send last sexp")
    "rd" '(racket-send-definiton :wk "racket send definition")
    "rr" '(chris/racket-run-and-switch-to-repl :wk "run racket and switch to repl")
    ))
#+end_src

** matlab

#+begin_src emacs-lisp
(straight-use-package 'matlab-mode)
(autoload 'matlab-mode "matlab" "Matlab Editing Mode" t)
(add-to-list
 'auto-mode-alist
 '("\\.m$" . matlab-mode))
(setq matlab-indent-function t)
(setq matlab-shell-command-switches '("-nosplash" "-nodesktop"))
(setq matlab-shell-command "matlab")

(defun chris/matlab-shell-run-buffer ()
  "Run matlab code"
  (interactive)
  (matlab-shell-run-command (concat "cd " default-directory))
  (matlab-shell-run-region (point-min) (point-max)))

(chris/leader-keys
 :keymaps 'matlab-mode-map
 :states 'normal
 "mr" '(chris/matlab-shell-run-buffer :wk "Run matlab buffer"))

(chris/leader-keys
  "cm" '(matlab-shell :wk "Open matlab shell"))
#+end_src


* Git
:PROPERTIES:
:header-args: :tangle init.el
:END:

#+begin_src emacs-lisp
(use-package magit
  :general
  (chris/leader-keys
    "g" '(:ignore t :wk "git")
    "gg" '(magit-status :wk "status")
    "gG" '(magit-list-repositories :wk "list repos"))
  :config
  (setq magit-push-always-verify nil)
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  (setq magit-repository-directories
        '(("~/.local/src"  . 2)
          ("~/.config/" . 2)))
  (setq git-commit-summary-max-length 50)
  :bind
  ("C-x g" . magit-status)
  ("C-x C-g" . magit-list-repositories))
#+end_src


* Terminal
:PROPERTIES:
:header-args: :tangle init.el
:END:

** VTerm

It is important to configure the system shell (in this case bash in the ~.bashrc~):

#+begin_src bash :tangle no
vterm_printf() {
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ]); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_cmd() {
    local vterm_elisp
    vterm_elisp=""
    while [ $# -gt 0 ]; do
        vterm_elisp="$vterm_elisp""$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's|\\|\\\\|g' -e 's|"|\\"|g')")"
        shift
    done
    vterm_printf "51;E$vterm_elisp"
}

find-file() {
    vterm_cmd find-file "$(realpath "${@:-.}")"
}
#+end_src

#+begin_src emacs-lisp
(use-package vterm
  :hook
  (vterm-mode . evil-emacs-state)
  :init
  (setq vterm-timer-delay 0.01))
#+end_src

** Eshell

*** General setup for eshell

#+begin_src emacs-lisp
(defun chris/configure-eshell ()
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)
  (setq eshell-history-size         10000
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t)
  (setq tramp-default-method "ssh"))

(use-package eshell
  :straight (:type built-in)
  :hook
  (eshell-first-time-mode . chris/configure-eshell)
  :config
  (with-eval-after-load 'esh-opt
    (setq eshell-destroy-buffer-when-process-dies t)
    (setq eshell-visual-commands '("ssh" "tail" "htop" "pulsemixer"))))
#+end_src

*** Git status

#+begin_src emacs-lisp
(defun eshell/gst (&rest args)
  (magit-status (pop args) nil)
  (eshell/echo))   ;; The echo command suppresses output
#+end_src

*** find

#+begin_src emacs-lisp
(defun eshell/f (filename &optional dir try-count)
  "Searches for files matching FILENAME in either DIR or the
current directory."
  (let* ((cmd (concat
               (executable-find "find")
               " " (or dir ".")
               "      -not -path '*/.git*'"
               " -and -not -path '*node_modules*'"
               " -and -not -path '*classes*'"
               " -and "
               " -type f -and "
               "-iname '" filename "'"))
         (results (shell-command-to-string cmd)))

    (if (not (s-blank-str? results))
        results
      (cond
       ((or (null try-count) (= 0 try-count))
        (eshell/f (concat filename "*") dir 1))
       ((or (null try-count) (= 1 try-count))
        (eshell/f (concat "*" filename) dir 2))
       (t "")))))

(defun eshell/ef (filename &optional dir)
  "Searches for the first matching filename and loads it into a
file to edit."
  (let* ((files (eshell/f filename dir))
         (file (car (s-split "\n" files))))
    (find-file file)))
#+end_src

*** clear

#+begin_src emacs-lisp
(defun eshell/clear ()
  "Clear `eshell' buffer."
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))
#+end_src

*** mkdir and cd

#+begin_src emacs-lisp
(defun eshell/mkdir-and-cd (dir)
  "Create a directory then cd into it."
  (make-directory dir t)
  (eshell/cd dir))
#+end_src

*** history

#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook
              (lambda ()
                (local-set-key (kbd "C-c h")
                               (lambda ()
                                 (interactive)
                                 (insert
                                  (completing-read "Eshell history: "
                                                       (delete-dups
                                                        (ring-elements eshell-history-ring))))))))
#+end_src


* Some other packages
:PROPERTIES:
:header-args: :tangle init.el
:END:

** Rainbow Mode

#+begin_src emacs-lisp
(use-package rainbow-mode)
#+end_src

** EMMS

#+begin_src emacs-lisp
(use-package emms
  :general
  (chris/leader-keys
    "m" '(:ignore t :wk "emms")
    "mm" '(emms :wk "emms")
    "mb" '(emms-smart-browse :wk "EMMS Smart Browse")
    "mi" '(emms-show :wk "EMMS show current song")
    "mn" '(emms-next :wk "EMMS next song")
    "mp" '(emms-previous :wk "EMMS previous song")
    "ml" '(emms-seek-forward :wk "EMMS go 10s forward")
    "mt" '(emms-toggle-repeat-track :wk "EMMS toggle repeat")
    "mh" '(emms-seek-backward :wk "EMMS go 10s backward")))
(require 'emms-setup)
(emms-all)
(emms-default-players)
(emms-mode-line 0)
(emms-playing-time 1)
(setq emms-source-file-default-directory "~/Music/"
      emms-playlist-buffer-name "*Music*"
      emms-info-asynchronously t
      emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
#+end_src
